# Сохранение словаря в PostgreSQL через psycopg2 с динамическими колонками

## Архитектура

- **config.py** — содержит константы для конфигурирования задания.
- **service.py** — содержит класс для взаимодействия с БД и upsert записей.
- **create_db.py** — скрипт для создания локальной базы данных и предоставления прав пользователю.
- **helpers.py** — вспомогательные функции для сериализации, определения типа данных, генерации алиасов и т.д.
- **logger.py** — класс для логирования сообщений уровней INFO и ERROR.
- **main.py** — основной скрипт, выполняющий весь функционал из `service.py` по вставке/обновлению данных из словарей.

---

## Подход к решению

1. Самое тяжелое лежит в `service.py` `upsert_records`
2. Я решил разделить на 2 списка значений на те, у которых есть идентификатор и где его нет. Такое решение связано с тем, что если не было идентификатора, то null значение не вставлялось из-за ограничения `null constraint`.
3. Я попробовал 2 способа: 
 - Вставлять `DEFAULT` вместо `null`. Но с `sql.SQL("DEFAULT")` - ругался, что недопустимое значение (хотя в создании таблицы я указываю, чтобы был `DEFAULT`).
 - Удалять `null` вовсе. А с чисткой `null` значений - psycopg ругался, что `index out of range` (кол-во колонок не соответствуют кол-ву значений).

4. Тогда я пришел к решению, что лучше разделить на списки с идентификатором и без, но тогда столкнулся с проблемой, что при обычном INSERT не обновляется таблица `pg_get_serial_sequence` и мне приходится ее обновлять вручную после UPSERT.
5. **Важно:** в отчете лежит логика, что записи с идентификаторами уже существуют в БД и поэтому при начальном запуске скрипта у нас обновленное кол-во будет равно кол-ву записей с идентификаторами. Возможно, тут я не до конца понял
6. Логгирование на уровне `INFO` происходит на операциях DDL и DML. `ERROR` логируется в `dict_to_pg.py` и изменения не комитятся (если происходит любая psycopg ошибка ну уровне SQL операций). Можно управлять с `rollback()` каждой транзакцией, но я решил управлять целиком всеми запросами.
7. **Расчитано, что `JSON` записи либо с `ID`, либо `UUID`, не микс**
8. Предполагается, что входные данные корректные. Например:
- даты уже приходят в нужном формате
- булевы значения (`true`/`false`) уже соответствуют ожидаемым типам
- Строки и целые числа

## Требования

1. Установлен `Python 3.11`
2. Установлен `PostgreSQL 17` локально
3. Установлен `poetry` `version = 0.1.0` для установки `pcycopg2`
4. Клиент `psql` должен быть доступен в `PATH`. Для Windows путь должен быть `C:\Program Files\PostgreSQL\17\bin\psql.exe`

---

## Установка и запуск

1. Установите [Poetry](https://python-poetry.org/docs/#installation) (версия `0.1.0` для проекта). 
    ```shell
    pipx install poetry
    ```
2. Перейдите в директорию prompai-tasks

   ```bash
   cd prompai-tasks
   ```

3. Установите зависимости (только `pcycopg2`):
    ```bash
    poetry install --no-root
    ```
---

## Файл `.env` и `config.ini`

- Перейдите в директорию task1

   ```bash
   cd task1
   ```

- Создайте файл `.env` по примеру `.env.example` в директории task1/, **обязательно поменяйте значения!** Пользователь, пароль и название БД подхватятся из этого файла.
    ```.env
    PG_PASSWORD=SuperSecretPassword!
    PG_NAME=dict_to_pg
    PG_USER=my_pg_user
    ```
- Создайте файл `config.ini` в директории task1/. **Не меняйте значения!**
   ```ini
   [postgres]
   host = localhost
   port = 5432
   dbname = $PG_NAME
   user = $PG_USER
   password = $PG_PASSWORD
   ```
---

## Локальная настройка базы данных PostgreSQL

Для запуска локальной базы данных используйте скрипт `create_db.py`

Откройте терминал и выполните команду:

```bash
poetry run python create_db.py
```

### ❗ Windows ❗
**Возможно вам придется ввести пароль `postgres` везде после выше выполненного скрипта, где запрашивается (6 раз).**

---
## Запустите sample.json (тестовые данные)

```bash
poetry run python main.py --table users --input sample.json
```
